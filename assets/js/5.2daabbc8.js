(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{351:function(t,a,s){"use strict";s.r(a);var r=s(43),n=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"꼬리물기-최적화-조찬기"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#꼬리물기-최적화-조찬기"}},[t._v("#")]),t._v(" 꼬리물기 최적화 - 조찬기")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://www.lvguowei.me/img/featured-recursion.png",alt:"꼬리물기 최적화"}})]),t._v(" "),s("hr"),t._v(" "),s("h2",{attrs:{id:"재귀함수"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#재귀함수"}},[t._v("#")]),t._v(" 재귀함수")]),t._v(" "),s("p",[t._v("재귀함수란 자기 자신을 호출하는 함수를 말합니다.")]),t._v(" "),s("p",[t._v("코드가 짧아져 가독성을 높일 수 있다는 장점이 있지만, stack overflow를 일으킬 수 있는 엄청난 위험성도 내재하고 있습니다.")]),t._v(" "),s("p",[t._v("함수를 호출할 때 함수의 입력 값(매개변수), return 값, 그리고 return 되었을 때 돌아갈 위치 값 등을 stack에 저장합니다.")]),t._v(" "),s("p",[t._v("이런 재귀의 특징을 정리하자면 다음과 같습니다.")]),t._v(" "),s("ul",[s("li",[t._v("무한 루프에 빠지지 않기 위해 일정한 탈출 조건이 있어야 한다.")]),t._v(" "),s("li",[t._v("코드를 단순화 할 수 있다.")]),t._v(" "),s("li",[t._v("재귀 함수는 호출 시 마다 stack 공간을 이용하므로 무리하게 호출하면 stack 오버플로우가 일어날 수 있다.")]),t._v(" "),s("li",[t._v("재귀 함수의 호출 횟수는 stack의 남은 공간과 재귀 함수의 지역 변수 사이즈에 따라 달라진다.")]),t._v(" "),s("li",[t._v("디버깅 및 실행 흐름을 파악하기 힘들다.")])]),t._v(" "),s("p",[t._v("다음 함수를 실행해봅시다. (결론부터 말하면 꼬리물기 최적화가 되어있지 않은 함수입니다.)")]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sum")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("n")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("n "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" n "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sum")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("n "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[s("img",{attrs:{src:"https://homoefficio.github.io/2015/07/27/%EC%9E%AC%EA%B7%80-%EB%B0%98%EB%B3%B5-Tail-Recursion/stack-overflow.png",alt:"n이 커지면 터져버린다"}})]),t._v(" "),s("p",[t._v("n이 매우 커지는 경우 stack overflow가 발생합니다.")]),t._v(" "),s("h2",{attrs:{id:"stack을-사용하지-않는-연산-지연-연산"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#stack을-사용하지-않는-연산-지연-연산"}},[t._v("#")]),t._v(" stack을 사용하지 않는 연산 (지연 연산)")]),t._v(" "),s("p",[t._v("각 언어스펙에는 연산자 중에 stack에 들어가지 않는 연산자가 지정되어있습니다.")]),t._v(" "),s("p",[t._v("javascript에서 지연연산이 가능한 연산자는 대표적으로 다음과 같습니다.")]),t._v(" "),s("ul",[s("li",[t._v("삼항연산자")]),t._v(" "),s("li",[t._v("&&")]),t._v(" "),s("li",[t._v("||")])]),t._v(" "),s("p",[t._v("지연평가를 하기 때문인데요, 각 경우를 살펴봅시다.")]),t._v(" "),s("ul",[s("li",[t._v("&& 연산의 경우, A && B 인 경우 A가 거짓인 경우 B를 확인하지 않는다.")]),t._v(" "),s("li",[t._v("|| 연산의 경우도 마찬가지.")]),t._v(" "),s("li",[t._v("삼항연산자의 경우 앞, 혹은 뒤의 연산만 실행하면 되므로 stack 메모리를 잡아먹지 않는다.")])]),t._v(" "),s("p",[t._v("지연 평가의 장점은 다음과 같습니다.")]),t._v(" "),s("ul",[s("li",[t._v("불필요한 계산을 하지 않으므로 빠른 계산이 가능하다.")]),t._v(" "),s("li",[t._v("무한 자료 구조를 사용 할 수 있다.")]),t._v(" "),s("li",[t._v("복잡한 수식에서 오류 상태를 피할 수 있다.")])]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("sum")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("v"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" prev "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  prev "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" v"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" v "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sum")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("v "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" prev"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" prev"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sum")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("h2",{attrs:{id:"꼬리물기"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#꼬리물기"}},[t._v("#")]),t._v(" 꼬리물기")]),t._v(" "),s("p",[t._v("쉽게 말하면 서브루틴 체인이 일어날 때 각 서브루틴의 return에 함수를 호출하는 것을 말합니다.")]),t._v(" "),s("p",[t._v("좀 더 단순화해서 말하자면 꼬리 호출(Tail Call)을 최적화하는 것을 말합니다.")]),t._v(" "),s("p",[t._v('꼬리 호출이란 위키피디아에 따르면 "서브루틴의 호출을 프로시저(procedure)의 마지막 행위로 수행하는 것"을 뜻합니다.')]),t._v(" "),s("p",[t._v("익숙한 예로는 재귀 호출을 생각하시면 됩니다.")]),t._v(" "),s("p",[t._v('그리고 최적화란 Return을 할 때 함수를 호출하면 "호출이 된" 함수에서 "호출을 한" 함수로 돌아오는 반환 지점을 가지고 있어야 합니다.')]),t._v(" "),s("p",[t._v('만약 "호출을 한" 함수가 메모리(실행 컨텍스트 - Argument, Local Variable)를 가지지 않는다면 "호출을 한" 함수로 돌아올 필요가 없으며,\n함수들이 한 번씩 "호출이 되고" 마지막으로 "호출이 된" 함수는 최초 함수 호출 지점으로 값을 반환하는 것을 뜻합니다.')]),t._v(" "),s("p",[t._v("이것이 가능하기 위해서는, return에서는 연산자를 사용하면 안 됩니다.(언어 스펙에서 지정한 스택에 메모리를 쌓지 않는 연산자는 사용 가능합니다.)")]),t._v(" "),s("p",[t._v("다음 함수들을 살펴볼까요?")]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 삼항 연산자는 JS 스펙에 정의된 콜스택에 메모리가 잡히지 않는 연산자입니다.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("factorial")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" acc "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" x "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),t._v(" acc "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("factorial")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("x "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" x "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" acc"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 삼항 연산자는 JS 스펙에 정의된 콜스택에 메모리가 잡히지 않는 연산자입니다.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("factorial")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("x")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" x "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" x "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("factorial")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("x "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("여기서 위 함수는 꼬리물기 최적화가 가능하고, 아래 함수는 꼬리물기 최적화가 불가능합니다.")]),t._v(" "),s("p",[t._v("왜일까요?")]),t._v(" "),s("p",[t._v("실행 컨텍스트(execution context)가 있으면 차례대로 함수가 호출이 된 순서대로 스택에 메모리가 쌓입니다.")]),t._v(" "),s("p",[t._v("아래 함수의 경우 자기 자신의 결과가 부모로 돌아갈 필요가 있습니다. x 와 곱하기 연산을 수행해야 하기 때문이죠.")]),t._v(" "),s("p",[t._v("하지만 최적화를 할 경우 (위 함수의 경우), 호출된 함수에 대한 메모리가 잡히지 않으므로 함수가 호출된 순서대로 실행되며 마지막 함수는 최초 호출 부의 값을 반환하고 종료됩니다.")]),t._v(" "),s("h2",{attrs:{id:"꼬리물기로-바꾸는-최적화-하는-방법"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#꼬리물기로-바꾸는-최적화-하는-방법"}},[t._v("#")]),t._v(" 꼬리물기로 바꾸는 (최적화 하는) 방법")]),t._v(" "),s("p",[t._v("우리가 상태를 유지해야 할 것이 있으면, 다음번 함수, 다음번 루틴에 인자로 넣어버리자")]),t._v(" "),s("p",[t._v("현재 함수 call의 위치애서 자기 자신의 메모리를 해제해 버리는 것.")]),t._v(" "),s("h2",{attrs:{id:"es6"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es6"}},[t._v("#")]),t._v(" ES6")]),t._v(" "),s("p",[t._v("자바스크립트 ES6 스펙에 이미 자바스크립트는 꼬리물기 최적화를 지원해야 한다고 명시되어 있습니다.")]),t._v(" "),s("p",[t._v("스펙 자체는 이미 이를 못박아두고 있는데요")]),t._v(" "),s("p",[t._v("그러나 실제로 브라우저에서 지원하는것은 safari, ios safari가 유일")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://kangax.github.io/compat-table/es6/",target:"_blank",rel:"noopener noreferrer"}},[t._v("지원 표"),s("OutboundLink")],1)]),t._v(" "),s("p",[t._v("크롬 65에서 꼬리물기 최적화를 하는 경우 17배 정도 성능 향상이 있다고 합니다.")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://www.linkedin.com/pulse/tail-call-optimizations-es6-michael-clark/",target:"_blank",rel:"noopener noreferrer"}},[t._v("크롬에서 꼬리물기 최적화"),s("OutboundLink")],1)]),t._v(" "),s("p",[t._v("언어별로 지원하고 지원하지 않는 언어가 있음")]),t._v(" "),s("ul",[s("li",[t._v("JVM은 안됨")]),t._v(" "),s("li",[t._v("그러나 JVM 위에서 동작하는 Clojure, Scala는 꼬리물기 최적화를 지원한다.")])])])}),[],!1,null,null,null);a.default=n.exports}}]);