# 꼬리물기 최적화 - 조찬기

![꼬리물기 최적화](https://www.lvguowei.me/img/featured-recursion.png)

---

## 재귀함수

재귀함수란 자기 자신을 호출하는 함수를 말합니다.

코드가 짧아져 가독성을 높일 수 있다는 장점이 있지만, stack overflow를 일으킬 수 있는 엄청난 위험성도 내재하고 있습니다.

함수를 호출할 때 함수의 입력 값(매개변수), return 값, 그리고 return 되었을 때 돌아갈 위치 값 등을 stack에 저장합니다.

이런 재귀의 특징을 정리하자면 다음과 같습니다.

- 무한 루프에 빠지지 않기 위해 일정한 탈출 조건이 있어야 한다.
- 코드를 단순화 할 수 있다.
- 재귀 함수는 호출 시 마다 stack 공간을 이용하므로 무리하게 호출하면 stack 오버플로우가 일어날 수 있다.
- 재귀 함수의 호출 횟수는 stack의 남은 공간과 재귀 함수의 지역 변수 사이즈에 따라 달라진다.
- 디버깅 및 실행 흐름을 파악하기 힘들다.

다음 함수를 실행해봅시다. (결론부터 말하면 꼬리물기 최적화가 되어있지 않은 함수입니다.)

```javascript
function sum(n) {
  if (n < 2) return n;
  return n + sum(n - 1);
}
```

![n이 커지면 터져버린다](https://homoefficio.github.io/2015/07/27/%EC%9E%AC%EA%B7%80-%EB%B0%98%EB%B3%B5-Tail-Recursion/stack-overflow.png)

n이 매우 커지는 경우 stack overflow가 발생합니다.

## stack을 사용하지 않는 연산 (지연 연산)

각 언어스펙에는 연산자 중에 stack에 들어가지 않는 연산자가 지정되어있습니다.

javascript에서 지연연산이 가능한 연산자는 대표적으로 다음과 같습니다.

- 삼항연산자
- &&
- ||

지연평가를 하기 때문인데요, 각 경우를 살펴봅시다.

- && 연산의 경우, A && B 인 경우 A가 거짓인 경우 B를 확인하지 않는다.
- || 연산의 경우도 마찬가지.
- 삼항연산자의 경우 앞, 혹은 뒤의 연산만 실행하면 되므로 stack 메모리를 잡아먹지 않는다.

지연 평가의 장점은 다음과 같습니다.

- 불필요한 계산을 하지 않으므로 빠른 계산이 가능하다.
- 무한 자료 구조를 사용 할 수 있다.
- 복잡한 수식에서 오류 상태를 피할 수 있다.

```javascript
const sum = (v, prev = 0) => {
  prev += v;
  return v > 1 ? sum(v - 1, prev) : prev;
};

sum(3);
```

## 꼬리물기

쉽게 말하면 서브루틴 체인이 일어날 때 각 서브루틴의 return에 함수를 호출하는 것을 말합니다.

좀 더 단순화해서 말하자면 꼬리 호출(Tail Call)을 최적화하는 것을 말합니다.

꼬리 호출이란 위키피디아에 따르면 "서브루틴의 호출을 프로시저(procedure)의 마지막 행위로 수행하는 것"을 뜻합니다.

익숙한 예로는 재귀 호출을 생각하시면 됩니다.

그리고 최적화란 Return을 할 때 함수를 호출하면 "호출이 된" 함수에서 "호출을 한" 함수로 돌아오는 반환 지점을 가지고 있어야 합니다.

만약 "호출을 한" 함수가 메모리(실행 컨텍스트 - Argument, Local Variable)를 가지지 않는다면 "호출을 한" 함수로 돌아올 필요가 없으며,
함수들이 한 번씩 "호출이 되고" 마지막으로 "호출이 된" 함수는 최초 함수 호출 지점으로 값을 반환하는 것을 뜻합니다.

이것이 가능하기 위해서는, return에서는 연산자를 사용하면 안 됩니다.(언어 스펙에서 지정한 스택에 메모리를 쌓지 않는 연산자는 사용 가능합니다.)

다음 함수들을 살펴볼까요?

```javascript
// 삼항 연산자는 JS 스펙에 정의된 콜스택에 메모리가 잡히지 않는 연산자입니다.
const factorial = (x, acc = 1) => {
  return x <= 1 ? acc : factorial(x - 1, x * acc);
};
```

```javascript
// 삼항 연산자는 JS 스펙에 정의된 콜스택에 메모리가 잡히지 않는 연산자입니다.
const factorial = (x) => {
  return x <= 0 ? 1 : x * factorial(x - 1);
};
```

여기서 위 함수는 꼬리물기 최적화가 가능하고, 아래 함수는 꼬리물기 최적화가 불가능합니다.

왜일까요?

실행 컨텍스트(execution context)가 있으면 차례대로 함수가 호출이 된 순서대로 스택에 메모리가 쌓입니다.

아래 함수의 경우 자기 자신의 결과가 부모로 돌아갈 필요가 있습니다. x 와 곱하기 연산을 수행해야 하기 때문이죠.

하지만 최적화를 할 경우 (위 함수의 경우), 호출된 함수에 대한 메모리가 잡히지 않으므로 함수가 호출된 순서대로 실행되며 마지막 함수는 최초 호출 부의 값을 반환하고 종료됩니다.

## 꼬리물기로 바꾸는 (최적화 하는) 방법

우리가 상태를 유지해야 할 것이 있으면, 다음번 함수, 다음번 루틴에 인자로 넣어버리자

현재 함수 call의 위치애서 자기 자신의 메모리를 해제해 버리는 것.

## ES6

자바스크립트 ES6 스펙에 이미 자바스크립트는 꼬리물기 최적화를 지원해야 한다고 명시되어 있습니다.

스펙 자체는 이미 이를 못박아두고 있는데요

그러나 실제로 브라우저에서 지원하는것은 safari, ios safari가 유일

[지원 표](https://kangax.github.io/compat-table/es6/)

크롬 65에서 꼬리물기 최적화를 하는 경우 17배 정도 성능 향상이 있다고 합니다.

[크롬에서 꼬리물기 최적화](https://www.linkedin.com/pulse/tail-call-optimizations-es6-michael-clark/)

언어별로 지원하고 지원하지 않는 언어가 있음

- JVM은 안됨
- 그러나 JVM 위에서 동작하는 Clojure, Scala는 꼬리물기 최적화를 지원한다.
